<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>what is scope</title>
  </head>
  <body>
    <script>
      /* 
        프로그래밍 언어에서 가장 기본적인 패러다임은 변수에 값을 저장하고 나중에 검색하거나 수정을 하는 것이다

        이러한 개념이 없었다면, 프로그램은 일을 수행하지 못하고, 프로그래밍은 노잼에 극혐이 되어버립니다.

        여기서 나오는 흥미로운 궁금증은 도대체 변수는 어디에 있는건가 입니다. 다른 말로 하자면 어디에 걔네들이 저장이 되는지 말입니다
        또한 어떻게 그 변수들을 나중에 다시 찾아오는지도 말이죠 그래서 이에 관해서 'Scope'라는 규칙과 이름을 정하고 사용합니다.

        compiler theory
        - tokenizing / lexing 
            => var a = 2;라는 문장이 있으면s var, a , = , 2, ;로 쪼갠다  (띄어쓰기는 의미가 있느냐 없느냐에 따라 토큰이 될 수도 안될 수도)
        - parsing
            => 쪼개진 토큰들을 모아서 나무를 만드는데 이것을 "AST(Abstract Syntax Tree)"라고 한다
                가장 첫번째 노드를 Variable Declaration 그 다음 자식 노드를 Identifier (a를 설명), 다른 자식 노드를 AssignmentExpression라고 하는데
                자식 노드는 NumericLiteral 이 있다 (2가 여기에 해당됨)
        - code generation
            =>AST 과정에서 실행 가능한 코드로 된다. 이 부분은 언어에 따라, 대상으로 하는 플랫폼 등에 따라 다릅니다.
              이 과정에서 기계는 a라는 변수를 형성하고 값을 저장합니다(ㅂ)
        
        하지만 자바스크립트 엔진은 위의 세가지 단계보다 더 크고 복잡합니다 

        자바스크립트에서는 코드가 실행되기 전에 컴파일이 발생합니다(microsecond or less!)

        Scope 이해하기
        -Scope에 대해서 배울 때, 대화의 관점에서 바라볼 것입니다. (누가 대화를 하고 있는가?)s

        1.Engine = 자바스크립트 프로그램을 처음부터 끝까지 컴파일을 하고 실행합니다
        2.Compiler = Engine의 친구로 코드를 분석 하거나 발생시킵니다.  
        3.Scope = Engine의 다른 친구로 선언된 모든 변수를 유지 관리하고 현재 실행중인 코드에 접근 할 수 있는 방법에 대해 엄격한 규칙을 적용합니다

        var a = 2; 라는 코드를 봤을 때, 아마 그저 코드 한 줄이라고 생각하겠지만, 엔진은 두 가지의 구별된 코드로 봅니다. 하나는 컴파일러가 컴파일을 할 때 처리하는 것,
        그리고 다른 하나는 엔진이 실행 할 때 처리하는 것으로 구분됩니다.

        이제 엔진과 컴파일러, 스코프가 var a = 2; 에 접근하는지 알아봅시다.

        컴파일러는 위 코드를 lexing을 통해서 토큰들로 분해하고 트리로 만들어 분석합니다. 하지만 컴파일러가 코드를 생성을 하게 되면 이 코드를 다르게 취급 할 것이다.

        합리적인 가정은 컴파일러가 의사 코드로 요약할 수 있는 코드를 생성한다는 것입니다. "변수에 메모리를 할당하고 레이블을 a로 지정한 다음 그 값 2를 변수에 고정하십시오"
        하지만 이건 정확하지 않습니다 

        컴파일러는 다음과 같이 진행합니다. 

        var a 를 마주치면 컴파일러는 스코프에게 콜렉션에 a 라는 변수가 이미 있는지 묻습니다. 만약 있다면 컴파일러는 이 선언을 무시하고 진행을 하고 그렇지 않으면
        컴파일러는 스코프에게 새로운 변수 a를 선언하고 콜렉션에 넣으라고 요청합니다.

        컴파일러는 a = 2 할당을 다루기 위해 엔진이 나중에 실행할 코드를 생성합니다  코드 엔진이 처음 실행될 때, 현재 스코프 콜렉션의 a가 접근 가능한지 물어봅니다
        접근이 가능하다면 변수를 사용하고 그렇지 않다면 엔진은 다른 곳을 찾아봅니다

        결국 엔진이 변수를 찾았다면 변수에 2를 할당하고 그렇지 않다면 엔진은 엔진은 에러를 선언합니다

        
        */
    </script>
  </body>
</html>
